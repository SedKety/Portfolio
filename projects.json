[
    {
        "thumbnail": "Images/Wizcape/WizcapeThumbnail.png",
        "id": "wizcape",
        "title": "Wizcape",
        "description": "3D dungeon crawler game made in Unity.",
         "githublink": "https://github.com/SedKety/Wiscape",
        "information": [
           "After a lecture at school we were introduced to the concept of fuzzy logic.",
           "I found it really interesting and wanted to try and implement it in a game.",
           "Though i knew i was sadly not math-nerdy enough to create a fuzzy logic graph with proper sets and all that,",
           "I figured i could try and make a simple version of it in a game.",
           "So i studied for hours on end trying to understand the concept and how it could be applied to game AI.",
           "After a few days of research and a notebook full of youtube tutorials listed by category on how to implement fuzzy logic,",
           "I started working on a small prototype in Unity.",
           "In the end it expanded to a skeleton and thus the concept for Wizcape was born.",
           "Wizcape is built around different enemy ai's that work together to kill the player.",
           "Their respective role varies on how they look, ranging from defensive to offensive to support from afar.",
           "  -The goblin flees after being hit, a very strong offensive enemy.",
           "  -The slime will act as the tank for the goblin, taking hits and distracting the player.",
           "  -The skeleton will rush at the player and attack and flee so the player has to move.",
           "  -The book will attack from range supporting the previous enemies.",
           "I had a blast making these ai's and have enjoyed learning from my fellow students on how to improve them further." 
        ], 

        "languages": ["C#", "Unity"],
        "tags": ["3D", "Game", "Team", "World Generation"],
        "features": [
            "Procedurally generated dungeons",
            "Different enemy types with unique behaviors",
            "Fuzzy logic for enemy AI"
        ],
        "images": ["Images/Wizcape/WizcapeDungeonGeneration.png", 
        "Images/Wizcape/WizcapeThumbnail.png", 
        "Images/Wizcape/WizcapeFighting.png", 
        "Images/Wizcape/WizcapeTrappedRoom.png"
      ],
      "syntax": "C#",
      "code": [ 
],
        "codeCaption": "Nothing for now"
    },

    {
        "githublink": "https://github.com/SedKety/Ketopia",
  "thumbnail": "Images/Ketopia/BigIslandShowcase.png",
  "id": "ketopia",
  "title": "Ketopia",
  "description": "An open world procedurally generated exploration survival game made in Unity.",
  "information": ["Though an older project i remember quite well how much fun me and my team had when creating this.",
    "This was our first big team project, so we wanted to show off our skills and make something ambitious.",
    "So we made Ketopia, a mix between exploration and survival. Which where our(The team's) favorite genres at the time.",
    "We thought we could learn alot from this project and decided to accept that though we probably wouldnt be able to finish it, we would learn a lot from it.",
    "While working on the world generation system i learned a lot about the math behind game development.",
    "Especially the grid based chunk spawning system taught me a lot about vectors and positions in 3D space.",
    "Additionally, i learned to use enum's and scriptable objects to make it as easy as possible for my artists to mess with."
],
  "languages": ["C#", "Unity"],
  "tags": ["Game", "3D", "Team", "World Generation", "Sole Programmer"],
  "features": [
    "Procedurally generated worlds",
    "Lots of different biomes with respective islands and flora",
    "Exploration system requiring the player to explore through biomes and rare islands",
    "Tool progression system for gathering resources",
    "Lore through crafting and interaction with NPC's",
    "Incredibly cute cats as character",
    "Interactable structures and NPCs"
  ],
  "images": [
    "Images/Ketopia/BigIslandShowcase.png",
    "Images/Ketopia/SunkenShip.png",
    "Images/Ketopia/KetopiaIsland.png"
  ],
  "syntax": "C#",
  "codeCaption": "Generator.cs - Generates the worlds",
  "code": [
    "I wish to make it clear that this is quite an old project of mine and the code is not as clean or well-optimized as my more recent projects.",
    "Nonetheless, I am proud of the work I did on this project and the skills I developed while working on it.",
    "",
    "using System.Collections.Generic;",
    "using UnityEngine;",
    "",
    "public class ChunkSpawner : MonoBehaviour",
    "{",
    "    public static ChunkSpawner instance;",
    "    public GameObject chunk;",
    "    public static GameObject chunkToSpawn;",
    "    public static List<GameObject> chunks = new();",
    "    public static int chunkCounter;",
    "",
    "    public Chunk startChunk;",
    "    public static Chunk currentChunk;",
    "    public List<Chunk> placeHolder;",
    "    public static List<Chunk> chunkTypes;",
    "",
    "    public static int maxChunkCount = 1040;",
    "    public static int chunkSize = 500;",
    "",
    "    public static float chunkTypeAmount = 0;",
    "    public void Start()",
    "    {",
    "        instance = this;",
    "        currentChunk = startChunk;",
    "        chunkTypeAmount = Random.Range(200, 400); chunkToSpawn = chunk;",
    "        chunkTypes = placeHolder;",
    "        chunks.Add(Instantiate(chunkToSpawn));",
    "        SpawnChunk(chunkToSpawn.transform);",
    "        chunkTypeAmount = Random.Range(200, 400);",
    "    }",
    "",
    "    public static void SpawnChunk(Transform pos)",
    "    {",
    "        Vector3[] directions = new Vector3[]",
    "        {",
    "            new Vector3(1, 0, 0),",
    "            new Vector3(-1, 0, 0),",
    "            new Vector3(0, 0, 1),",
    "            new Vector3(0, 0, -1),",
    "            new Vector3(1, 0, 1),",
    "            new Vector3(1, 0, -1),",
    "            new Vector3(-1, 0, 1),",
    "            new Vector3(-1, 0, -1),",
    "            new Vector3(1, 1, 0),",
    "            new Vector3(-1, 1, 0),",
    "            new Vector3(0, 1, 1),",
    "            new Vector3(0, 1, -1),",
    "            new Vector3(1, 1, 1),",
    "            new Vector3(1, 1, -1),",
    "            new Vector3(-1, 1, 1),",
    "            new Vector3(-1, 1, -1),",
    "            new Vector3(0, 1, 0),",
    "            new Vector3(1, -1, 0),",
    "            new Vector3(-1, -1, 0),",
    "            new Vector3(0, -1, 1),",
    "            new Vector3(0, -1, -1),",
    "            new Vector3(1, -1, 1),",
    "            new Vector3(1, -1, -1),",
    "            new Vector3(-1, -1, 1),",
    "            new Vector3(-1, -1, -1),",
    "            new Vector3(0, -1, 0)",
    "        };",
    "",
    "        List<GameObject> newChunks = new();",
    "",
    "        for (int i = 0; i < directions.Length; i++)",
    "        {",
    "            Vector3 newPosition = pos.position + directions[i] * chunkSize;",
    "            if (!IsChunkAtPosition(newPosition))",
    "            {",
    "                GameObject newChunk = SpawnNewChunkAtPosition(newPosition);",
    "                newChunks.Add(newChunk);",
    "            }",
    "        }",
    "",
    "        foreach (GameObject chunk in newChunks)",
    "        {",
    "            for (int i = 0; i < directions.Length; i++)",
    "            {",
    "                Vector3 newPosition = chunk.transform.position + directions[i] * chunkSize;",
    "                if (!IsChunkAtPosition(newPosition))",
    "                {",
    "                    SpawnNewChunkAtPosition(newPosition);",
    "                }",
    "            }",
    "        }",
    "    }",
    "",
    "    private static GameObject SpawnNewChunkAtPosition(Vector3 newPosition)",
    "    {",
    "        if (chunkTypeAmount <= 0)",
    "        {",
    "            chunkTypeAmount = Random.Range(200, 400);",
    "            Chunk lastChunk = currentChunk;",
    "            currentChunk = chunkTypes[Random.Range(0, chunkTypes.Count)];",
    "            if (currentChunk.name == lastChunk.name)",
    "            {",
    "                currentChunk = chunkTypes[Random.Range(0, chunkTypes.Count)];",
    "                print(currentChunk.name);",
    "            }",
    "        }",
    "        GameObject newChunk = Instantiate(chunkToSpawn, newPosition, Quaternion.identity);",
    "        chunkTypeAmount -= 1;",
    "        chunks.Add(newChunk);",
    "        chunkCounter++;",
    "        newChunk.GetComponent<ChunkScript>().chunkCount = chunkCounter;",
    "        newChunk.GetComponent<ChunkScript>().chunk = currentChunk;",
    "        if (chunks.Count > maxChunkCount)",
    "        {",
    "            for (int j = 0; j < 9; j++)",
    "            {",
    "                Destroy(chunks[j]);",
    "                chunks.RemoveAt(j);",
    "            }",
    "        }",
    "        return newChunk;",
    "    }",
    "",
    "    public static void AnnihilateChunks()",
    "    {",
    "        print(chunks.Count);",
    "        for (int i = 0; i < chunks.Count; i++)",
    "        {",
    "            chunks[i].gameObject.SetActive(false);",
    "        }",
    "    }",
    "",
    "    public static bool IsChunkAtPosition(Vector3 position)",
    "    {",
    "        foreach (GameObject existingChunk in chunks)",
    "        {",
    "            if (existingChunk.transform.position == position)",
    "            {",
    "                return true;",
    "            }",
    "        }",
    "        return false;",
    "    }",
    "}"
]
    },

    {
        "githublink": "https://github.com/FirePixel8422/TerraTopia",
        "thumbnail": "Images/Terratopia/concept.png",
        "id": "terratopia",
        "title": "Terratopia",
        "languages":["C#", "Unity"],
        "tags": ["World Generation", "Team", "Multiplayer", "3D", "Game"],
        "images": ["Images/Terratopia/TerratopiaTrailer.mp4", "Images/Terratopia/concept.png"],
        "features": [
            "Procedurally generated worlds", 
            "Unity netcode allowing for up to 4 players",
            "Customizable player skins",
            "Online multiplayer",
            "Turn based combat/exploration/building"
                    ],
        
        "description": "Online multiplayer turnbased procedurally generated pvp game inspired by Polytopia",
        "information": [
            "This game is heavily inspired by the game Polytopia, a game i grew up with.",
            "It is an turn based combat game where players train units, place structures and take over cities.",
            "I had a chat about it with a fellow programmer and he seemed as excited as me to recreate it",
            "So we did, our own spin on Polytopia. our twist? Making it 3D, so the terrain could make movement/combat harder.",
            "This project has tought me alot, from learning builder patterns, to making procedurally generated worlds.",
            "Im gratefull for the opportunity, and the team that got me to create this game."
        ],
        "syntax": "C#",
        "codeCaption": "Tilegenerator - Makes the map baseplate",
        "code": [
    "using System.Collections;",
    "using System.Collections.Generic;",
    "using System.Linq;",
    "using Unity.Burst;",
    "using UnityEngine;",
    "",
    "//This struct is used to generate a grid within its constructor.",
    "[BurstCompile]",
    "public struct TileGenerator",
    "{",
    "    public TileGenerator(NoiseData noiseData, int width, int length, int seed, Transform parent, GameObject cloudPrefab, out Dictionary<Vector2, TileBase> tilesToReturn, out Dictionary<Vector2, GameObject> cloudsToReturn)",
    "    {",
    "        tilesToReturn = new Dictionary<Vector2, TileBase>();",
    "        cloudsToReturn = new Dictionary<Vector2, GameObject>();",
    "",
    "        var tileHeightMultiplier = noiseData.tileHeightMultiplier;",
    "        var tileHeight = 0f;",
    "",
    "        //Generates data for each tile",
    "        var tiles = noiseData.GetTiles(seed, width, length);",
    "",
    "        //Instantiates every tile with before-achieved the tile data",
    "        for (int i = 0; i < tiles.Length; i++)",
    "        {",
    "            tileHeight = tiles[i].Item1.constHeight == 0 ? tiles[i].Item3 * tileHeightMultiplier : tiles[i].Item1.constHeight;",
    "",
    "            GameObject tileObj = Object.Instantiate(tiles[i].Item1.tileGO, new Vector3(tiles[i].Item2.x, tileHeight, tiles[i].Item2.y), Quaternion.identity, parent);",
    "            GameObject cloudObj = Object.Instantiate(cloudPrefab, new Vector3(tiles[i].Item2.x, tileHeight, tiles[i].Item2.y), Quaternion.identity, parent);",
    "",
    "            TileBase tileBase = tileObj.GetComponent<TileBase>();",
    "            tileBase.ownedByPlayerTeamId = -1;",
    "",
    "            tilesToReturn.Add(tiles[i].Item2, tileBase);",
    "            cloudsToReturn.Add(tiles[i].Item2, cloudObj);",
    "",
    "            if (tilesToReturn.Last().Value.TryGetComponent(out TileBase tile))",
    "            {",
    "                tile._perlinHeight = tiles[i].Item3;",
    "            }",
    "        }",
    "    }",
    "}"
                ]

    },

    {
        "id": "hunters_hideout",
        "title": "Hunter's Hideout",
        "description": "VR survival hunting game set in a hunting cabin.",
        "information": [
            "School wanted for us(my team) to make a VR game.",
            "Though none of us had any real experience with VR we thought this concept was great.",
            "Even though the concept was incredibly large we still decided to do it.",
            "First few weeks where spent researching vr and how it works.",
            "In the end i wrote my own custom vr interaction system which worked pretty well.",
            "After that i made some custom enemy ai's and guns to shoot them.",
            "Even though i had no prior experience with ai nor vr the game turned out pretty well.",
            "I'm happy we made this game due to the fact that i learnt so much from it."
        ],
        "languages": ["C#", "Unity"],
        "tags": ["3D", "Game", "VR", "Team", "World Generation","Sole Programmer"], 
        "features": [
            "Custom VR interaction system",
            "Variety of weapons",
            "Different enemy types with unique behaviors",
            "Hunting and gathering system with a smart drone ai"
        ],
        "thumbnail": "Images/HuntersHideout/Showcase.png",
        "images": ["Images/HuntersHideout/InfectedBear.png", "/Images/HuntersHideout/Showcase.png"],
        "githublink": "https://github.com/SedKety/Hunter-s-Hideout",
        "codeCaption": "Entity.cs - Base class for all NPC's",
        "syntax": "C#",
        "code": [
"using System.Collections;",
"using System.Collections.Generic;",
"using System.Linq;",
"using UnityEngine;",
"using UnityEngine.AI;",
"public enum EntityStates",
"{",
"    searching,", 
"    standing,",
"    running,",
"    attacking,",
"    fleeing,",
"    dead,", 
"    nothing,", 
"}",
"[RequireComponent(typeof(NavMeshAgent))]",
"[RequireComponent(typeof(Animator))]",
"public abstract class Entity : MonoBehaviour, IDamagable",
"{",
"    public EntityStats npcStats;",
"    protected NavMeshAgent agent;",
"    protected Animator animator;",
"",
"    //decides how close the entity can be away from an object before interacting with it",
"    #region npcstat variables",
"",
"    //Health variables",
"    protected int _health;",
"    protected bool _canHeal;",
"    protected int _healthRegen;",
"    protected float _healthRegenTimer;",
"",
"    //Scared variables",
"    protected float _scaredTime;",
"    protected Vector2 _standStillTime;",
"    protected float _scaredTimeMultiplier;",
"",
"    //Movement variables",
"    protected float _distanceOffsetTillNextPosition;",
"    protected float _movementSpeedNormal;",
"    protected float _movementSpeedSprint;",
"    protected float _distanceRange;",
"",
"    //Attacking variables",
"    protected int _damage;",
"    protected int _hitCount;",
"    protected float _hitDelay;",
"    protected int _contactWithdrawalChance;",
"    protected float _attackChance;",
"    ",
"    //Misc variables",
"    [HideInInspector] public GameObject _headGo;",
"    protected EntityStates _startState;",
"    #endregion",
"",
"    //The position the entity will/wants to move to",
"    protected Vector3 currentDestination;",
"",
"    protected bool isDead;",
"",
"    [SerializeField] protected EntityStates _currentState;",
"",
"",
"    protected Coroutine coroutine;",
"",
"",
"    protected bool isRunning;",
"",
"",
"    protected float standStillChance;",
"",
"",
"    [SerializeField] bool shouldDebugPrint;",
"",
"    public AudioSource hit;",
"    //Take the stats from the npcStats scriptable object and applies those to this object",
"    protected virtual void Awake()",
"    {",
"        isDead = false;",
"        InitStats();",
"        animator = GetComponent<Animator>();",
"        agent = GetComponent<NavMeshAgent>();",
"        ActOnState(_startState);",
"    }",
"    protected virtual void Start()",
"    {",
"",
"    }",
"    public virtual void InitStats()",
"    {",
"        //Movement variables",
"        _distanceRange = npcStats.distanceRange;",
"        _movementSpeedNormal = npcStats.movementSpeedNormal;",
"        _movementSpeedSprint = npcStats.movementSpeedSprint;",
"        _distanceOffsetTillNextPosition = npcStats.distanceOffsetTillNextPosition;",
"",
"        //Scared Variables",
"        _scaredTime = npcStats.scaredTime;",
"        _standStillTime = npcStats.standStillTime;",
"        _scaredTimeMultiplier = npcStats.scaredTimeMultiplier;",
"",
"        //Attacking variables",
"        _damage = npcStats.damage;",
"        _hitCount = npcStats.hitCount;",
"        _contactWithdrawalChance = npcStats.contactWithdrawalChance;",
"        _hitDelay = npcStats.hitDelay;",
"",
"        //Health variables",
"        _health = npcStats.health;",
"        if (npcStats.canHeal == true)",
"        {",
"            _healthRegen = npcStats.healthRegen;",
"            _healthRegenTimer = npcStats.healthRegenTimer;",
"            _canHeal = npcStats.canHeal;",
"        }",
"",
"        //Misc variables",
"        _startState = npcStats.startState;",
"        _headGo = npcStats.headGO;",
"    }",
"    //Makes the entity respond to certain states",
"    protected virtual void ActOnState(EntityStates _state)",
"    {",
"        if (shouldDebugPrint) { print(_state); }",
"        if (isDead) return;",
"        _currentState = _state;",
"        //print(\"Entity is entering: \" + _state + \"  state\");",
"        switch (_state)",
"        {",
"            case EntityStates.fleeing:",
"                {",
"                    if (coroutine != null)",
"                    {",
"                        StopCoroutine(coroutine);",
"                    }",
"                    coroutine = StartCoroutine(RunAway()); break;",
"                }",
"            case EntityStates.running:",
"                {",
"                    if (coroutine != null)",
"                    {",
"                        StopCoroutine(coroutine);",
"                    }",
"                    coroutine = StartCoroutine(RunAway()); break;",
"                }",
"            case EntityStates.standing:",
"                {",
"                    if (coroutine != null)",
"                    {",
"                        StopCoroutine(coroutine);",
"                    }",
"                    StartCoroutine(StandStill()); break;",
"                }",
"            case EntityStates.searching:",
"                {",
"                    if (coroutine != null)",
"                    {",
"                        StopCoroutine(coroutine);",
"                    }",
"                    StartCoroutine(Search()); break;",
"                }",
"            case EntityStates.dead:",
"                {",
"                    if (coroutine != null)",
"                    {",
"                        StopCoroutine(coroutine);",
"                    }",
"                    agent.destination = transform.position;",
"                    isDead = true;",
"                    break;",
"                }",
"            case EntityStates.attacking:",
"                {",
"                    if (coroutine != null)",
"                    {",
"                        StopCoroutine(coroutine);",
"                    }",
"                    StartCoroutine(Attack());",
"                    break;",
"                }",
"            case EntityStates.nothing:",
"                break;",
"        }",
"    }",
"",
"    [ContextMenu(\"TakeDamage\")]",
"    public virtual void TakeDamage(int damageTaken)",
"    {",
"        if (shouldDebugPrint) { print(gameObject.name + \" Has taken \" + damageTaken + \": Damage\");  } ",
"        _health -= damageTaken;",
"        hit.Play();",
"        if (_health <= 0)",
"        {",
"            OnDeath();",
"        }",
"    }",
"",
"",
"    [ContextMenu(\"OnDeath\")]",
"    protected virtual void OnDeath()",
"    {",
"        if (shouldDebugPrint) { print(gameObject.name + \" Has died\"); }",
"        if (!isDead)",
"        {",
"            EntityManager.CallOnEntityDeath(this);",
"            ActOnState(EntityStates.dead);",
"            animator.SetBool(\"IsDead\", true);",
"            animator.SetBool(\"IsWalking\", false);",
"            animator.SetBool(\"IsRunnning\", false);",
"            animator.SetBool(\"IsIdle\", false);",
"        }",
"    }",
"",
"",
"    protected virtual IEnumerator StandStill()",
"    {",
"        //doesnt animate anymore",
"        animator.SetBool(\"IsIdle\", true);",
"        animator.SetBool(\"IsWalking\", false);",
"        animator.SetBool(\"IsRunnning\", false);",
"        yield return new WaitForSeconds(Random.Range(_standStillTime.x, _standStillTime.y));",
"        if (_currentState != EntityStates.standing) { yield return null; }",
"        ActOnState(EntityStates.searching);",
"    }",
"    protected virtual IEnumerator Search()",
"    {",
"        GetRandomPosToMoveTo();",
"        ChangeSpeed(_movementSpeedNormal);",
"        //switches to the movementAnimation",
"        animator.SetBool(\"IsWalking\", true);",
"        animator.SetBool(\"IsIdle\", false);",
"        animator.SetBool(\"IsRunnning\", false);",
"        while (_currentState == EntityStates.searching)",
"        {",
"            yield return new WaitForSeconds(0.1f);",
"            if (Vector3.Distance(transform.position, currentDestination) <= _distanceOffsetTillNextPosition)",
"            {",
"                if (Random.Range(0, 100) <= standStillChance)",
"                {",
"                    ActOnState(EntityStates.standing);",
"                    break;",
"                }",
"                GetRandomPosToMoveTo();",
"            }",
"        }",
"    }",
"    //Tries to generate a position to move to, will return positive if it has found one",
"    public virtual bool GetRandomPosToMoveTo()",
"    {",
"        Vector3 randomPos = transform.position + Random.insideUnitSphere * _distanceRange;",
"        //print(randomPos);",
"        NavMeshHit hit;",
"        if (NavMesh.SamplePosition(randomPos, out hit, 100, NavMesh.AllAreas))",
"        {",
"            agent.destination = hit.position;",
"            currentDestination = hit.position;",
"            // print(hit.position);",
"            return true;",
"        }",
"        else",
"        {",
"            print(\"No position found\");",
"        }",
"        return false;",
"    }",
"",
"    protected virtual IEnumerator RunAway()",
"    {",
"        ChangeSpeed(_movementSpeedSprint);",
"        animator.SetBool(\"IsRunning\", true);",
"        animator.SetBool(\"IsWalking\", false);",
"        animator.SetBool(\"IsIdle\", false);",
"        GetRandomPosToMoveTo();",
"        float timeTillEnd = _scaredTime;",
"        while (timeTillEnd > 0)",
"        {",
"            timeTillEnd -= Time.deltaTime * _scaredTimeMultiplier;",
"            if (Vector3.Distance(transform.position, currentDestination) <= _distanceOffsetTillNextPosition)",
"            {",
"                GetRandomPosToMoveTo();",
"            }",
"            yield return null;",
"        }",
"        ChangeSpeed(_movementSpeedNormal);",
"        ActOnState(EntityStates.searching);",
"        yield return null;",
"    }",
"    protected virtual void ChangeSpeed(float speed)",
"    {",
"        agent.speed = speed;",
"    }",
"",
"    protected virtual IEnumerator Attack()",
"    {",
"        currentDestination = Hideout.GetHideOutPosClosestToV3(transform.position).position;",
"        ChangeSpeed(_movementSpeedSprint);",
"        agent.destination = currentDestination;",
"",
"        //Checks whether the entity has reached the destination of the agent",
"        while(Vector3.Distance(transform.position, currentDestination) >= _distanceOffsetTillNextPosition)",
"        {",
"            yield return new WaitForSeconds(0.1f);",
"        }",
"        ",
"        //Rolls a random number to see whether the entity should or should not flee and should continue attacking",
"        var chance = Random.Range(0, 100);",
"        if (chance <= _contactWithdrawalChance) { ActOnState(EntityStates.fleeing); yield return null; }",
"",
"        bool isAttacking = true;",
"",
"        while (isAttacking)",
"        {",
"            for (int i = 0; i < _hitCount; i++)",
"            {",
"                Hideout.instance.TakeDamage(_damage);",
"                yield return new WaitForSeconds(_hitDelay);",
"            }",
"            isAttacking = false;",
"        }",
"        ActOnState(EntityStates.fleeing);",
"        yield return null;",
"    }",
"}"
        ]

    },

    {
        "id": "delicious-in-ocean",
        "title": "Delicious In Ocean",
        "tags": ["3D", "Game", "VR", "Team"],
        "languages": ["C#", "Unity"],
        "description": "A VR cooking game where you kill and hunt to gather ingredients to cook with.",
        "information": [
            "This project was a school project with the theme of hunting sea monsters and using vr",
            "When me and my team where brainstorming for ideas i thought of an anime i was watching at the time",
            "Delicious in ocean, a cooking anime in which the characters hunt monsters and eat them",
            "So i suggested we mix hunting and cooking in a VR game",
            "Everybody agreed and thus, Delicious in ocean was born",
            "I learnt alot about boss ai and how to effectively communicate with other programmers"
        ],
        "features": [
            "VR ship steering",
            "Open world exploration",
            "Multiple bossfights",
            "Variety of weapons"
        ],
        "thumbnail": "Images/DeliciousInOcean/Kraken.png",
        "images": ["Images/DeliciousInOcean/Kraken.png", "Images/DeliciousInOcean/Trailer.mp4"],
        "githublink": "https://github.com/JustinMakesGames/Delicious-and-Ocean",
        "syntax": "C#",
        "codeCaption": "Kraken.cs - Final boss script",
        "code": [
"using System.Collections;",
"using System.Collections.Generic;",
"using System.Linq;",
"using UnityEngine;",
"",
"public class Kraken : ActorParent",
"{",
"    [Header(\"Tentacle spawning settings\")]",
"    [SerializeField] private GameObject _tentacleGO;",
"",
"    private List<GameObject> _activeTentacles = new List<GameObject>();",
"    private List<Vector3> _usedPositions = new List<Vector3>();",
"",
"    [SerializeField] private float _spawnTentacleAttempt;",
"",
"    [SerializeField] private int _maxTentacles = 3;",
"",
"    public List<Transform> tentacleSpawnPositions;",
"    public Transform boatTransform;",
"",
"    protected override void Awake()",
"    {",
"        base.Awake();",
"        StartCoroutine(TentacleSpawner());",
"    }",
"",
"    public void OnTentacleDeath(GameObject tentacle, Vector3 originalPos)",
"    {",
"        _activeTentacles.Remove(tentacle);",
"        _usedPositions.Remove(tentacle.transform.position);",
"    }",
"",
"    private IEnumerator TentacleSpawner()",
"    {",
"        while (true)",
"        {",
"            if(_activeTentacles.Count < _maxTentacles)",
"            {",
"                SpawnTentacle();",
"                print(\"Could spawn a tentacle, yipsers\");",
"            }",
"",
"            yield return new WaitForSeconds(_spawnTentacleAttempt);",
"        }",
"    }",
"",
"    //Returns a rrandom position that isnt occupated yet",
"    private Transform RandomTentacleSpawnPos",
"    {",
"        get",
"        {",
"            var availablePositions = tentacleSpawnPositions",
"                .Where(pos => !_usedPositions.Contains(pos.position))",
"                .ToList();",
"",
"            if (availablePositions.Count == 0)",
"                return null;",
"",
"            var randomPos = availablePositions[Random.Range(0, availablePositions.Count)];",
"            _usedPositions.Add(randomPos.position);",
"",
"            if(randomPos == null)",
"            {",
"                Debug.LogWarning(\"RandomTentacleSpawnPos returned null, no available positions left.\");",
"                return null;",
"            }",
"",
"            return randomPos;",
"        }",
"    }",
"",
"",
"    private void SpawnTentacle()",
"    {",
"        var tentacleSpawnPos = RandomTentacleSpawnPos;",
"        if(tentacleSpawnPos == null)",
"        {",
"            Debug.LogWarning(\"No available tentacle spawn position found.\");",
"            return;",
"        }",
"        var tentacleGO = InstantiateChild(_tentacleGO, tentacleSpawnPos);",
"        tentacleGO.transform.Rotate(gameObject.name == \"Left\" ? new Vector3(0, -90, 0) : new Vector3(0, 90, 0));",
"",
"        tentacleGO.transform.parent = tentacleSpawnPos;",
"        _activeTentacles.Add(tentacleGO);",
"    }",
"",
"    [ContextMenu(\"Kill the squid\")]",
"    protected override void OnActorDeath()",
"    {",
"        WinManager.Instance.HandleWinning();",
"        base.OnActorDeath();",
"    }",
"}"
        ]
    },

    {
        "githublink": "https://github.com/SedKety/Pest-Control", 
        "id": "pest_patrol",
        "title": "Pest Patrol",
        "thumbnail": "Images/PestPatrol/MainScreen.png",
        "description": "Tower defense game where you act as an pest control agent",
        "languages": [
            "C#",
            "Unity"
        ],
        "tags": [
            "3D",
            "Game",
            "Team"
        ],
        "information": [
            "In pest patrol you create your own path with road-sections.",
            "This was the first real project where me(and the other programmer) started using OOP",
            "Additionally we wanted to learn as much as possible, so we made some rules.",
            "1. No colliders, everything is distance based which makes the game pretty performant.",
            "2. Integrate OOP as much as possible, example: towers/enemies/structures/roads",
            "3. Look into alternatives to ienumerator, which we found in async and custom update loops"
        ],
        "features": [
            "Smart targetting towers",
            "Variety of enemies/towers",
            "Procedural wave system, can go to infinity. No limits.",
            "Gamemodes",
            "Different maps"
        ],
        "syntax": "C#",
        "images": ["Images/PestPatrol/MainScreen.png", "Images/PestPatrol/Gameplay.png"]
    },

    {
        "thumbnail": "Images/IntoxicatedBeachDrive/MainScreen.png",
        "images": ["Images/IntoxicatedBeachDrive/MainScreen.png", "Images/IntoxicatedBeachDrive/Gameplay.png"],
        "id": "intoxicated_beach_drive",
        "title": "Intoxicated Beach Drive",
        "description": "A 3D driving game where you drive around on a beach hitting as many obstacles as possible while intoxicated.",
        "information": [
            "My role in this project was the main programmer, scrum master, designer and ui/ux'er.",
            "This was a small project me and some friends made for a game jam.",
            "The theme was 'vacation' with the spin being 'illegal' so we thought of a driving game on a beach while intoxicated.",
            "In the game you try to run over as many beach balls, umbrellas and beach towels as possible.",
            "All the while you have to traverse a randomly generated beach with ramps, hills and water.",
            "If you are lucky you might come across a crate of beer which increases speed",
            "I learnt alot about unity's physics system and how to make a simple driving game." 
        ],
        "tags": ["3D", "Game", "World Generation", "Team", "Game Jam", "Sole Programmer"],
        "languages": ["C#", "Unity"],
        "githublink": "https://github.com/SedKety/Intoxicated-Beach-Drive",
        "features": [
            "Randomly generated beach",
            "Variety of obstacles to hit", 
            "Simple driving mechanics",
            "Ramps to do stunts with"
        ],
        "syntax": "C#",
        "codeCaption": "BeachGenerator.cs - Generates the beach layout"
    }, 

    {
        "githublink": "https://github.com/SedKety/ECS",
        "thumbnail": "Images/ECS/ECSThumbnail.png",
        "id": "ecs-library",
        "title": "ECS",
        "description": "A custom C++ Entity Component System library.",
        "information": [
            "ECS stands for: Entity-Component-System",
            "Its an architecture used for many game engines. My inspiration being taken from Bevvy and Unity.",
            "Entities have components, components store data, and systems loop over entities to act on that data(component).",
            "My motive for this project was to integrate it in me and a friend of mine's custom game engine named Kranium.",
            "Though progress has been put to a halt now, i am quite happy on how the ECS turned out.",
            "Mostly because this is my first time programming in c++"
    
    ],
        "languages": ["C++"],
        "tags": ["Library", "Low-Level", "Learning", "System Architecture", "Sole Programmer"],
        "features": [
            "Easy-to-create new components",
            "Easy to use APIs",
            "Modular systems"
        ],
        "images": ["Images/ECS/ECSPhysics.png"],
        "syntax": "C++",
        "codeCaption": "Entity.h – Core Entity Structure",
        "code": [
            "#pragma once",
            "#include <iostream>",
            "#include <vector>",
            "#include <memory>",
            "#include \"ECS.h\"",
            "#include \"Component.h\"",
            "",
            "struct Entity {",
            "    int id; // Identifier for this entity, never 0",
            "    std::vector<Component*> components; // List of components this entity has",
            "",
            "    Entity(int id) : id(id) {}",
            "",
            "    // Deconstructor",
            "    ~Entity() {",
            "        components.clear();",
            "        components.shrink_to_fit(); // Free unused memory",
            "    }",
            "",
            "public:",
            "    template<typename T, typename... Args>",
            "    void AddComponent(Args&&... args) {",
            "        T* comp = new T(std::forward<Args>(args)...);",
            "        components.push_back(comp);",
            "    }",
            "",
            "    template<typename T>",
            "    T* GetComponent() {",
            "        for (auto* comp : components) {",
            "            if (auto* desired = dynamic_cast<T*>(comp)) {",
            "                return desired;",
            "            }",
            "        }",
            "        return nullptr;",
            "    }",
            "",
            "    template<typename T>",
            "    const bool HasComponentOfType() const {",
            "        for (const auto* comp : components) {",
            "            if (dynamic_cast<const T*>(comp)) return true;",
            "        }",
            "        return false;",
            "    }",
            "",
            "    std::vector<Component*> GetAllComponents() { return components; }",
            "};"
        ]
    },

    {
        "githublink": "https://github.com/SedKety/LASM",
        "thumbnail" : "Images/Assembly/BubbleSort.png", 
        "id": "assembly-sorting",
        "title": "Sorting Algorithms in Assembly",
        "description": "A series of optimized sorting algorithms written fully in x86 assembly.",
        "information": [
            "A friend kept asking me why his programs where running so slowly.",
            "So the only logical approach was to study for days on end on how programming ACTUALLY works.",
            "I spent a week studying non stop, drawing boards full, watching videos and reading articles.",
            "Documentation after documentation i even wrote alot myself",
            "I finally learned how it worked and could now accurately explain to my friend why his code was slow.",
            "My knowledge on everything from CPU architecture to memory management had increased drastically.",
            "I wrote a sorting algorithm in assembly just to test how incredibly performant low level code could be.",
            "Not only was the exe smaller then i could imagine, the code was like 5 opcodes compared to my previous c# code.",
            "To anyone reading this, please. learn assembly, study cpu architecture, it will make you a better programmer.",
            "The gallery shows the code executed on the cpu with the x86dbg tool(graph and direct code)"
        ],
        "languages": ["MASM32"],
        "tags": ["Low-Level", "Learning", "System Architecture", "Solo", "Sole Programmer"],
        "features": [
            "Bubble sort implementation",
            "Insertion sort implementation",
            "Custom loops"
        ],
        "syntax": "MASM32",
        "images": ["Images/Assembly/BubbleSort.png", "Images/Assembly/BubbleSortGraph.png"],
        "codeCaption": "bubble_sort.asm – MASM32 Implementation",
"code": [
    ".386",
    "",
    ".data ; The section to hold identifiers",
    "",
    "   arrayToSort db 9, 1, 5, 6, 3",
    "   arraySize equ $ - arrayToSort",
    "",
    "   noSwapString db \"No need to swap, the number after this is higher then the previous one.\", 0, 13, 10",
    "   swapString db \"Had to swap, the number after this is less then the previous one\", 0, 13, 10",
    "",
    ".code ; The section that holds all the code",
    "",
    "main:",
    "",
    "   mov ecx, arraySize",
    "   dec ecx ; Remove one from the ecx, this will be used to check whether or not we have completed the for loop",
    "",
    "outer_loop:",
    "   mov esi, 0 ; Pointer to the current iteration of the array",
    "   mov edx, ecx",
    "",
    "inner_loop:",
    "   mov al, [arrayToSort + esi] ; A pointer to the current iterator's memory address + the offset of esi",
    "   mov bl, [arrayToSort + esi + 1] ; Pointer to the next iterator's memory address",
    "   cmp al, bl",
    "   jle no_swap ; If the next integer is smaller than this one, it calls the no_swap function",
    "   jge swap",
    "",
    "no_swap: ; Called when the next number is bigger then the previous number",
    "   invoke StdOut, noSwapString",
    "   inc esi ; Increase the current iteration of the array by 1",
    "   dec edx ; Remove 1 from the arraySize checker, to see if we have reached the end of the array",
    "   cmp edx, 0 ; Check if we have reached the end of the array",
    "   jnz outer_loop ; If edx(the current iteration - arraysize) is not zero then we jump back to the outerLoop",
    "",
    "   dec ecx ; Remove one from the current arraysize, because the largest number has already been pushed to the back",
    "   jnz inner_loop",
    "",
    "   invoke ExitProcess, 0",
    "",
    "swap: ; Called when the next number is smaller than the previous one",
    "",
    "   invoke StdOut, swapString",
    "   mov [arrayToSort + esi], bl",
    "   mov [arrayToSort + esi + 1], al",
    "",
    "end main"
]

    },

    {
        "githublink": "https://github.com/SedKety/Renderer",
        "thumbnail": "Images/PPM/PPM_Renderer_Thumbnail.png",
        "id": "ppm-renderer",
        "title": "PPM Renderer",
        "description": "A simple vertex renderer which writes directly to a PPM image.",
        "information": ["I've always been fascinated by rendering software.",
           "One day i came across a video of my favorite programming youtuber: Sebastian Lague",
           "In the video he showcased how he was able to draw vertices and faces on the screen",
           "It was pretty late so i got the 3am drive to start programming, so i did.",
           "This is the result of it, after a few days programming i have a working ppm renderer",
           "It rasterizes the faces of a mesh, in short. it checks what pixels are inside a face(triangle)",
           "Then draws those pixels in the color of that face",
           "In the end i send all the pixel data to a ppm file and then open it in a software such as: Gimp",
           "I learnt alot about the inner workings of rendering and more importantly. How faces actually work."
    ],
        "languages": ["C#"],
        "tags": ["Learning", "2D", "System Architecture",  "Solo", "Sole Programmer"],
        "features": [
            "Loops through all triangles and sees what pixels are in them",
            "Outputs a raw PPM image",
            "Support for any 2D mesh as long as it is triangulized",
            "Not dependent on any libraries"
        ],


        "images": ["Images/PPM/PPM_Renderer_Thumbnail.png", "Images/PPM/PPM_Variety.png"],
        "syntax": "C#",
        "codeCaption": "Renderer.cs – Rasterizer to PPM",
                "code": [
    "using Renderer.DataTypes;",
    "using Renderer.DataTypes.Structs;",
    "using Renderer.Maths;",
    "using System;",
    "using System.Collections.Generic;",
    "using System.Linq;",
    "using System.Text;",
    "using System.Threading.Tasks;",
    "",
    "namespace Renderer",
    "{",
    "    internal static class Renderer",
    "    { ",
    "        public static void CreateRender(int pmmWidth, int pmmHeight, int frameCount, string path = null)",
    "        {",
    "            int3[,] pixelBuffer = new int3[pmmWidth, pmmHeight];",
    "",
    "            List<TwoDimensionalTriangle> triangles = new List<TwoDimensionalTriangle>();",
    "",
    "            #region Objects to render",
    "",
    "            var gridSizes = new float2(pmmWidth, pmmHeight);",
    "",
    "            var triCount = 8;",
    "            for (int i = 0; i < triCount; i++)",
    "            {",
    "                triangles.Add(TwoDimensionalTriangle.CreateRandomTriangle(",
    "                    new float2(",
    "                        Random.Shared.Next(0, pmmWidth),",
    "                        Random.Shared.Next(0, pmmHeight)",
    "                    ),",
    "                    gridSizes,",
    "                   Random.Shared.Next(32, 128) / 1000f",
    "                ));",
    "            }",
    "",
    "            var faceCount = 8;",
    "            Face[] faces = new Face[faceCount];",
    "",
    "            for (int i = 0; i < faceCount; i++)",
    "            {",
    "                faces[i] = Face.CreateRandomFace(",
    "                    new float2(",
    "                        Random.Shared.Next(0, pmmWidth),",
    "                        Random.Shared.Next(0, pmmHeight)",
    "                    ),",
    "                    Random.Shared.Next(32, 64)",
    "                );",
    "            }",
    "",
    "            foreach (var face in faces)",
    "            {",
    "                triangles.AddRange(face.tris);",
    "            }",
    "",
    "            #endregion",
    "",
    "            for (int i = 0; i < frameCount; i++)",
    "            {",
    "                // Use of the ternary operator to decide whether or not to generate a new path for the ppm file, or use the set one",
    "                var curPath = path != null ? path : $\"Output{i}.pmm\";",
    "",
    "                StreamWriter ppmFile = new StreamWriter(curPath);",
    "",
    "                #region PMM BoilerPlate",
    "                // The magic number making it so the ppm's numbers will be recognised as whole numbers, instead of bytes(code P6)",
    "                ppmFile.WriteLine(\"P3\");",
    "",
    "                // Specifying the width and height of the ppm image",
    "                ppmFile.WriteLine($\"{pmmWidth} {pmmHeight}\");",
    "",
    "                // The maximum color value, which is 255 for RGB",
    "                ppmFile.WriteLine(255);",
    "                ppmFile.WriteLine();",
    "                #endregion",
    "",
    "                var curPixelPos = new float2(0, 0);",
    "                int3 pixelColor = new int3(0, 0, 0);",
    "",
    "                // The y value of the grid(aka the height)",
    "                for (int y = 0; y < pmmHeight; y++)",
    "                {",
    "                    // The x value of the grid(aka the width)",
    "                    for (int x = 0; x < pmmWidth; x++)",
    "                    {",
    "                        curPixelPos.x = x;",
    "                        curPixelPos.y = y;",
    "",
    "                        bool isInTriangle = false;",
    "                        for (int o = 0; o < triangles.Count; o++)",
    "                        {",
    "                            if (TwoDimensionalTriangle.IsPixelInTriangle(triangles[o], curPixelPos))",
    "                            {",
    "                                isInTriangle = true;",
    "                                pixelColor = triangles[o].RGB;",
    "                            }",
    "                        }",
    "",
    "                        if (isInTriangle)",
    "                        {",
    "                            // If the pixel is in the triangle, set it to the color of the triangle",
    "                            pixelBuffer[x, y] = pixelColor;",
    "                        }",
    "                        else",
    "                        {",
    "                            // If the pixel is not in the triangle, set it to black",
    "                            pixelBuffer[x, y] = new int3(0, 0, 0);",
    "                        }",
    "",
    "                        // Create a pixel buffer, not used with ppm format. but useful when I'll introduce raylib or some other graphics library",
    "                        ppmFile.Write(pixelBuffer[x, y].r);",
    "                        ppmFile.Write(\" \");",
    "                        ppmFile.Write(pixelBuffer[x, y].g);",
    "                        ppmFile.Write(\" \");",
    "                        ppmFile.Write(pixelBuffer[x, y].b);",
    "                        ppmFile.Write(\"   \");",
    "                    }",
    "                    ppmFile.Write(\"\\n\");",
    "                }",
    "                ppmFile.Close();",
    "            }",
    "        }",
    "    }",
    "}"
                        ]
    },

    {
        "thumbnail": "Images/CPU/CPU.png",
        "images": ["Images/CPU/CPU.png"],
        "features": [
            "Takes in bytes as opcodes and translates that into eecuted code",
            "Basic opcodes(jmp, load, mov, inc, sub, cmp)",
            "Conditional jumps(jne, je, jl, jle)",
            "16 registers to store variables in",
            "Flags that are set upon arithmetic operations"
        ],

        "githublink": "https://github.com/SedKety/CPU",
        "id": "cpu",
        "title": "Virtual CPU",
        "languages": [
            "C#"
        ],

        "description": "Allows for the execution of opcodes in a virtual enviroment",
        "information": [
            "The cpu takes an input program in the form of a byte array.",
            "Every byte-value(instruction) has a corresponding opcode(not official, not x64/x86), custom.",
            "These are then executed and the program counter increments to the next instruction",
            "This will continue on untill an infinite loop(repetative jumps) or an 0x00 byte is found"
        ],
        "tags": [
            "Learning",
            "Library",
            "System Architecture",
            "Low-Level",
            "Solo",
            "Sole Programmer"
        ],
        "syntax": "C#",
        "codeCaption": "Opcodes - Whole program in opcodes",
        "code": [
"namespace CPU",
"{",
"    public enum OpCodes : byte",
"    {",
"        //Program-deciding opcodes",
"        END = 0x00, // End of program",
"",
"        //Memory opcodes",
"        LOAD = 0x01, // Load value into a register",
"",
"        //Jump opcodes",
"        JMP = 0x02,",
"",
"        //Arithmetic opcodes",
"        ADD = 0x03,",
"        CMP = 0x04,",
"        SUB = 0x05,",
"        INC = 0x06,",
"        DEC = 0x07",
"    }",
"",
"    public enum JmpConditionals : byte",
"    {",
"        Immediate = 0x00,",
"",
"        Equal = 0x01,",
"        NotEqual = 0x02,",
"",
"        GreaterThen = 0x03,",
"        LessThen = 0x04,",
"    }",
"",
"    public class Program",
"    {",
"        static byte[] program = new byte[256]; // For now just 256 considering the program size might differ later on",
"",
"        //Entry point, no shit",
"        static void Main(string[] args)",
"        {",
"            program[0] = (byte)OpCodes.LOAD; //Load a value",
"            program[1] = 0x00; //Register it loads in is R0",
"            program[2] = 0xa0; //Value that is stored in R0, 160",
"",
"            program[3] = (byte)OpCodes.LOAD; //Load another value",
"            program[4] = 0x01; //In register R1",
"            program[5] = 0x01; //Value that is stored in R1, 1",
"",
"            program[6] = (byte)OpCodes.SUB; // We subtract the values of the two registers ",
"            program[7] = 0x00; //R0, We also place the result in this",
"            program[8] = 0x01; //R1",
"",
"            program[9] = (byte)OpCodes.INC;",
"            program[10] = 0x01; //Incrementing R1",
"",
"            program[11] = (byte)OpCodes.CMP;",
"            program[12] = 0x00; //R0",
"            program[13] = 1; //R1",
"",
"            program[14] = (byte)OpCodes.JMP;",
"            program[15] = (byte)JmpConditionals.GreaterThen; ",
"            program[16] = 0x09; //PC we want to jump to",
"",
"            Cpu cpu = new Cpu();",
"            cpu.Run(program);",
"        }",
"    }",
"}"
                ]
    }


]