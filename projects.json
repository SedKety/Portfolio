[

    {
        "thumbnail": "../Images/ECS/ECS_Thumbnail.png",
        "id": "ecs-library",
        "title": "ECS",
        "description": "A custom C++ Entity Component System library.",
        "information": [
            "ECS stands for: Entity-Component-System",
            "Its an architecture used for many game engines. My inspiration being taken from Bevvy and Unity.",
            "Entities have components, components store data, and systems loop over entities to act on that data(component).",
            "My motive for this project was to integrate it in me and a friend of mine's custom game engine named Kranium.",
            "Though progress has been put to a halt now, i am quite happy on how the ECS turned out.",
            "Mostly because this is my first time programming in c++"
    
    ],
        "languages": ["C++"],
        "tags": ["Library", "Low-Level", "Efficient", "Learning"],
        "features": [
            "Easy-to-create new components",
            "Easy to use APIs",
            "Modular systems"
        ],
        "images": ["../Images/ECS/ECS_Physics_Showcase.png"],
        "codeCaption": "Entity.h – Core Entity Structure",
        "code": [
            "#pragma once",
            "#include <iostream>",
            "#include <vector>",
            "#include <memory>",
            "#include \"ECS.h\"",
            "#include \"Component.h\"",
            "",
            "struct Entity {",
            "    int id; // Identifier for this entity, never 0",
            "    std::vector<Component*> components; // List of components this entity has",
            "",
            "    Entity(int id) : id(id) {}",
            "",
            "    // Deconstructor",
            "    ~Entity() {",
            "        components.clear();",
            "        components.shrink_to_fit(); // Free unused memory",
            "    }",
            "",
            "public:",
            "    template<typename T, typename... Args>",
            "    void AddComponent(Args&&... args) {",
            "        T* comp = new T(std::forward<Args>(args)...);",
            "        components.push_back(comp);",
            "    }",
            "",
            "    template<typename T>",
            "    T* GetComponent() {",
            "        for (auto* comp : components) {",
            "            if (auto* desired = dynamic_cast<T*>(comp)) {",
            "                return desired;",
            "            }",
            "        }",
            "        return nullptr;",
            "    }",
            "",
            "    template<typename T>",
            "    const bool HasComponentOfType() const {",
            "        for (const auto* comp : components) {",
            "            if (dynamic_cast<const T*>(comp)) return true;",
            "        }",
            "        return false;",
            "    }",
            "",
            "    std::vector<Component*> GetAllComponents() { return components; }",
            "};"
        ]
    },

    {
        "thumbnail" : "../Images/Assembly/Bubble_Sort.png",
        "id": "assembly-sorting",
        "title": "Sorting Algorithms in Assembly",
        "description": "A series of optimized sorting algorithms written fully in x86 assembly.",
        "information": [
            "A friend kept asking me why his programs where running so slowly.",
            "So the only logical approach was to study for days on end on how programming ACTUALLY works.",
            "I spent a week studying non stop, drawing boards full, watching videos and reading articles.",
            "Documentation after documentation i even wrote alot myself",
            "I finally learned how it worked and could now accurately explain to my friend why his code was slow.",
            "My knowledge on everything from CPU architecture to memory management had increased drastically.",
            "I wrote a sorting algorithm in assembly just to test how incredibly performant low level code could be.",
            "Not only was the exe smaller then i could imagine, the code was like 5 opcodes compared to my previous c# code.",
            "To anyone reading this, please. learn assembly, study cpu architecture, it will make you a better programmer.",
            "The gallery shows the code executed on the cpu with the x86dbg tool(graph and direct code)"
        ],
        "languages": ["MASM32"],
        "tags": ["Algorithms", "Low-Level", "Learning"],
        "features": [
            "Bubble sort implementation",
            "Insertion sort implementation",
            "Custom loops"
        ],
        "images": ["../Images/Assembly/Bubble_Sort.png", "../Images/Assembly/Bubble_Sort_Graph.png"],
        "codeCaption": "bubble_sort.asm – MASM32 Implementation",
"code": [
    ".386",
    "",
    ".data ; The section to hold identifiers",
    "",
    "   arrayToSort db 9, 1, 5, 6, 3",
    "   arraySize equ $ - arrayToSort",
    "",
    "   noSwapString db \"No need to swap, the number after this is higher then the previous one.\", 0, 13, 10",
    "   swapString db \"Had to swap, the number after this is less then the previous one\", 0, 13, 10",
    "",
    ".code ; The section that holds all the code",
    "",
    "main:",
    "",
    "   mov ecx, arraySize",
    "   dec ecx ; Remove one from the ecx, this will be used to check whether or not we have completed the for loop",
    "",
    "outer_loop:",
    "   mov esi, 0 ; Pointer to the current iteration of the array",
    "   mov edx, ecx",
    "",
    "inner_loop:",
    "   mov al, [arrayToSort + esi] ; A pointer to the current iterator's memory address + the offset of esi",
    "   mov bl, [arrayToSort + esi + 1] ; Pointer to the next iterator's memory address",
    "   cmp al, bl",
    "   jle no_swap ; If the next integer is smaller than this one, it calls the no_swap function",
    "   jge swap",
    "",
    "no_swap: ; Called when the next number is bigger then the previous number",
    "   invoke StdOut, noSwapString",
    "   inc esi ; Increase the current iteration of the array by 1",
    "   dec edx ; Remove 1 from the arraySize checker, to see if we have reached the end of the array",
    "   cmp edx, 0 ; Check if we have reached the end of the array",
    "   jnz outer_loop ; If edx(the current iteration - arraysize) is not zero then we jump back to the outerLoop",
    "",
    "   dec ecx ; Remove one from the current arraysize, because the largest number has already been pushed to the back",
    "   jnz inner_loop",
    "",
    "   invoke ExitProcess, 0",
    "",
    "swap: ; Called when the next number is smaller than the previous one",
    "",
    "   invoke StdOut, swapString",
    "   mov [arrayToSort + esi], bl",
    "   mov [arrayToSort + esi + 1], al",
    "",
    "end main"
]

    },

    {
        "thumbnail": "../Images/PPM/PPM_Renderer_Thumbnail.png",
        "id": "ppm-renderer",
        "title": "PPM Renderer",
        "description": "A simple vertex renderer which writes directly to a PPM image.",
        "information": ["I've always been fascinated by rendering software.",
           "One day i came across a video of my favorite programming youtuber: Sebastian Lague",
           "In the video he showcased how he was able to draw vertices and faces on the screen",
           "It was pretty late so i got the 3am drive to start programming, so i did.",
           "This is the result of it, after a few days programming i have a working ppm renderer",
           "It rasterizes the faces of a mesh, in short. it checks what pixels are inside a face(triangle)",
           "Then draws those pixels in the color of that face",
           "In the end i send all the pixel data to a ppm file and then open it in a software such as: Gimp",
           "I learnt alot about the inner workings of rendering and more importantly. How faces actually work."
    ],
        "languages": ["C#", "Gimp"],
        "tags": ["Rendering", "Learning", "2D", "File manipulation"],
        "features": [
            "Loops through all triangles and sees what pixels are in them",
            "Outputs a raw PPM image",
            "Support for any 2D mesh as long as it is triangulized",
            "Not dependent on any libraries"
        ],


        "images": ["../Images/PPM/PPM_Renderer_Thumbnail.png", "../Images/PPM/PPM_Variety.png"],
        "codeCaption": "Renderer.cs – Rasterizer to PPM",
                "code": [
    "using Renderer.DataTypes;",
    "using Renderer.DataTypes.Structs;",
    "using Renderer.Maths;",
    "using System;",
    "using System.Collections.Generic;",
    "using System.Linq;",
    "using System.Text;",
    "using System.Threading.Tasks;",
    "",
    "namespace Renderer",
    "{",
    "    internal static class Renderer",
    "    { ",
    "        public static void CreateRender(int pmmWidth, int pmmHeight, int frameCount, string path = null)",
    "        {",
    "            int3[,] pixelBuffer = new int3[pmmWidth, pmmHeight];",
    "",
    "            List<TwoDimensionalTriangle> triangles = new List<TwoDimensionalTriangle>();",
    "",
    "            #region Objects to render",
    "",
    "            var gridSizes = new float2(pmmWidth, pmmHeight);",
    "",
    "            var triCount = 8;",
    "            for (int i = 0; i < triCount; i++)",
    "            {",
    "                triangles.Add(TwoDimensionalTriangle.CreateRandomTriangle(",
    "                    new float2(",
    "                        Random.Shared.Next(0, pmmWidth),",
    "                        Random.Shared.Next(0, pmmHeight)",
    "                    ),",
    "                    gridSizes,",
    "                   Random.Shared.Next(32, 128) / 1000f",
    "                ));",
    "            }",
    "",
    "            var faceCount = 8;",
    "            Face[] faces = new Face[faceCount];",
    "",
    "            for (int i = 0; i < faceCount; i++)",
    "            {",
    "                faces[i] = Face.CreateRandomFace(",
    "                    new float2(",
    "                        Random.Shared.Next(0, pmmWidth),",
    "                        Random.Shared.Next(0, pmmHeight)",
    "                    ),",
    "                    Random.Shared.Next(32, 64)",
    "                );",
    "            }",
    "",
    "            foreach (var face in faces)",
    "            {",
    "                triangles.AddRange(face.tris);",
    "            }",
    "",
    "            #endregion",
    "",
    "            for (int i = 0; i < frameCount; i++)",
    "            {",
    "                // Use of the ternary operator to decide whether or not to generate a new path for the ppm file, or use the set one",
    "                var curPath = path != null ? path : $\"Output{i}.pmm\";",
    "",
    "                StreamWriter ppmFile = new StreamWriter(curPath);",
    "",
    "                #region PMM BoilerPlate",
    "                // The magic number making it so the ppm's numbers will be recognised as whole numbers, instead of bytes(code P6)",
    "                ppmFile.WriteLine(\"P3\");",
    "",
    "                // Specifying the width and height of the ppm image",
    "                ppmFile.WriteLine($\"{pmmWidth} {pmmHeight}\");",
    "",
    "                // The maximum color value, which is 255 for RGB",
    "                ppmFile.WriteLine(255);",
    "                ppmFile.WriteLine();",
    "                #endregion",
    "",
    "                var curPixelPos = new float2(0, 0);",
    "                int3 pixelColor = new int3(0, 0, 0);",
    "",
    "                // The y value of the grid(aka the height)",
    "                for (int y = 0; y < pmmHeight; y++)",
    "                {",
    "                    // The x value of the grid(aka the width)",
    "                    for (int x = 0; x < pmmWidth; x++)",
    "                    {",
    "                        curPixelPos.x = x;",
    "                        curPixelPos.y = y;",
    "",
    "                        bool isInTriangle = false;",
    "                        for (int o = 0; o < triangles.Count; o++)",
    "                        {",
    "                            if (TwoDimensionalTriangle.IsPixelInTriangle(triangles[o], curPixelPos))",
    "                            {",
    "                                isInTriangle = true;",
    "                                pixelColor = triangles[o].RGB;",
    "                            }",
    "                        }",
    "",
    "                        if (isInTriangle)",
    "                        {",
    "                            // If the pixel is in the triangle, set it to the color of the triangle",
    "                            pixelBuffer[x, y] = pixelColor;",
    "                        }",
    "                        else",
    "                        {",
    "                            // If the pixel is not in the triangle, set it to black",
    "                            pixelBuffer[x, y] = new int3(0, 0, 0);",
    "                        }",
    "",
    "                        // Create a pixel buffer, not used with ppm format. but useful when I'll introduce raylib or some other graphics library",
    "                        ppmFile.Write(pixelBuffer[x, y].r);",
    "                        ppmFile.Write(\" \");",
    "                        ppmFile.Write(pixelBuffer[x, y].g);",
    "                        ppmFile.Write(\" \");",
    "                        ppmFile.Write(pixelBuffer[x, y].b);",
    "                        ppmFile.Write(\"   \");",
    "                    }",
    "                    ppmFile.Write(\"\\n\");",
    "                }",
    "                ppmFile.Close();",
    "            }",
    "        }",
    "    }",
    "}"
                        ]
    },

    {
  "thumbnail": "Images/Ketopia/Big_Island_Showcase.png",
  "id": "ketopia",
  "title": "Ketopia",
  "description": "An open world procedurally generated exploration survival game made in Unity.",
  "information": ["Though an older project i remember quite well how much fun me and my team had when creating this.",
    "This was our first big team project, so we wanted to show off our skills and make something ambitious.",
    "So we made Ketopia, a mix between exploration and survival. Which where our(The team's) favorite genres at the time.",
    "We thought we could learn alot from this project and decided to accept that though we probably wouldnt be able to finish it, we would learn a lot from it.",
    "While working on the world generation system i learned a lot about the math behind game development.",
    "Especially the grid based chunk spawning system taught me a lot about vectors and positions in 3D space.",
    "Additionally, i learned to use enum's and scriptable objects to make it as easy as possible for my artists to mess with."
],
  "languages": ["C#", "Unity"],
  "tags": ["Game", "3D", "Exploration", "Survival", "Team", "World Generation", "Procedural generation"],
  "features": [
    "Procedurally generated worlds",
    "Lots of different biomes with respective islands and flora",
    "Exploration system requiring the player to explore through biomes and rare islands",
    "Tool progression system for gathering resources",
    "Lore through crafting and interaction with NPC's",
    "Incredibly cute cats as character",
    "Interactable structures and NPCs"
  ],
  "images": [
    "Images/Ketopia/Big_Island_Showcase.png",
    "Images/Ketopia/Sunken_Ship.png",
    "Images/Ketopia/Ketopia_Island.png"
  ],
  "codeCaption": "Generator.cs - Generates the worlds",
  "code": [
    "I wish to make it clear that this is quite an old project of mine and the code is not as clean or well-optimized as my more recent projects.",
    "Nonetheless, I am proud of the work I did on this project and the skills I developed while working on it.",
    "",
    "using System.Collections.Generic;",
    "using UnityEngine;",
    "",
    "public class ChunkSpawner : MonoBehaviour",
    "{",
    "    public static ChunkSpawner instance;",
    "    public GameObject chunk;",
    "    public static GameObject chunkToSpawn;",
    "    public static List<GameObject> chunks = new();",
    "    public static int chunkCounter;",
    "",
    "    public Chunk startChunk;",
    "    public static Chunk currentChunk;",
    "    public List<Chunk> placeHolder;",
    "    public static List<Chunk> chunkTypes;",
    "",
    "    public static int maxChunkCount = 1040;",
    "    public static int chunkSize = 500;",
    "",
    "    public static float chunkTypeAmount = 0;",
    "    public void Start()",
    "    {",
    "        instance = this;",
    "        currentChunk = startChunk;",
    "        chunkTypeAmount = Random.Range(200, 400); chunkToSpawn = chunk;",
    "        chunkTypes = placeHolder;",
    "        chunks.Add(Instantiate(chunkToSpawn));",
    "        SpawnChunk(chunkToSpawn.transform);",
    "        chunkTypeAmount = Random.Range(200, 400);",
    "    }",
    "",
    "    public static void SpawnChunk(Transform pos)",
    "    {",
    "        Vector3[] directions = new Vector3[]",
    "        {",
    "            new Vector3(1, 0, 0),",
    "            new Vector3(-1, 0, 0),",
    "            new Vector3(0, 0, 1),",
    "            new Vector3(0, 0, -1),",
    "            new Vector3(1, 0, 1),",
    "            new Vector3(1, 0, -1),",
    "            new Vector3(-1, 0, 1),",
    "            new Vector3(-1, 0, -1),",
    "            new Vector3(1, 1, 0),",
    "            new Vector3(-1, 1, 0),",
    "            new Vector3(0, 1, 1),",
    "            new Vector3(0, 1, -1),",
    "            new Vector3(1, 1, 1),",
    "            new Vector3(1, 1, -1),",
    "            new Vector3(-1, 1, 1),",
    "            new Vector3(-1, 1, -1),",
    "            new Vector3(0, 1, 0),",
    "            new Vector3(1, -1, 0),",
    "            new Vector3(-1, -1, 0),",
    "            new Vector3(0, -1, 1),",
    "            new Vector3(0, -1, -1),",
    "            new Vector3(1, -1, 1),",
    "            new Vector3(1, -1, -1),",
    "            new Vector3(-1, -1, 1),",
    "            new Vector3(-1, -1, -1),",
    "            new Vector3(0, -1, 0)",
    "        };",
    "",
    "        List<GameObject> newChunks = new();",
    "",
    "        for (int i = 0; i < directions.Length; i++)",
    "        {",
    "            Vector3 newPosition = pos.position + directions[i] * chunkSize;",
    "            if (!IsChunkAtPosition(newPosition))",
    "            {",
    "                GameObject newChunk = SpawnNewChunkAtPosition(newPosition);",
    "                newChunks.Add(newChunk);",
    "            }",
    "        }",
    "",
    "        foreach (GameObject chunk in newChunks)",
    "        {",
    "            for (int i = 0; i < directions.Length; i++)",
    "            {",
    "                Vector3 newPosition = chunk.transform.position + directions[i] * chunkSize;",
    "                if (!IsChunkAtPosition(newPosition))",
    "                {",
    "                    SpawnNewChunkAtPosition(newPosition);",
    "                }",
    "            }",
    "        }",
    "    }",
    "",
    "    private static GameObject SpawnNewChunkAtPosition(Vector3 newPosition)",
    "    {",
    "        if (chunkTypeAmount <= 0)",
    "        {",
    "            chunkTypeAmount = Random.Range(200, 400);",
    "            Chunk lastChunk = currentChunk;",
    "            currentChunk = chunkTypes[Random.Range(0, chunkTypes.Count)];",
    "            if (currentChunk.name == lastChunk.name)",
    "            {",
    "                currentChunk = chunkTypes[Random.Range(0, chunkTypes.Count)];",
    "                print(currentChunk.name);",
    "            }",
    "        }",
    "        GameObject newChunk = Instantiate(chunkToSpawn, newPosition, Quaternion.identity);",
    "        chunkTypeAmount -= 1;",
    "        chunks.Add(newChunk);",
    "        chunkCounter++;",
    "        newChunk.GetComponent<ChunkScript>().chunkCount = chunkCounter;",
    "        newChunk.GetComponent<ChunkScript>().chunk = currentChunk;",
    "        if (chunks.Count > maxChunkCount)",
    "        {",
    "            for (int j = 0; j < 9; j++)",
    "            {",
    "                Destroy(chunks[j]);",
    "                chunks.RemoveAt(j);",
    "            }",
    "        }",
    "        return newChunk;",
    "    }",
    "",
    "    public static void AnnihilateChunks()",
    "    {",
    "        print(chunks.Count);",
    "        for (int i = 0; i < chunks.Count; i++)",
    "        {",
    "            chunks[i].gameObject.SetActive(false);",
    "        }",
    "    }",
    "",
    "    public static bool IsChunkAtPosition(Vector3 position)",
    "    {",
    "        foreach (GameObject existingChunk in chunks)",
    "        {",
    "            if (existingChunk.transform.position == position)",
    "            {",
    "                return true;",
    "            }",
    "        }",
    "        return false;",
    "    }",
    "}"
]
    },

    {
        "thumbnail": "../Images/Wizcape/Wizcape_Thumbnail.png",
        "id": "wizcape",
        "title": "Wizcape",
        "description": "3D dungeon crawler game made in Unity.",

        "information": [
           "After a lecture at school we were introduced to the concept of fuzzy logic.",
           "I found it really interesting and wanted to try and implement it in a game.",
           "Though i knew i was sadly not math-nerdy enough to create a fuzzy logic graph with proper sets and all that,",
           "I figured i could try and make a simple version of it in a game.",
           "So i studied for hours on end trying to understand the concept and how it could be applied to game AI.",
           "After a few days of research and a notebook full of youtube tutorials listed by category on how to implement fuzzy logic,",
           "I started working on a small prototype in Unity.",
           "In the end it expanded to a skeleton and thus the concept for Wizcape was born.",
           "Wizcape is built around different enemy ai's that work together to kill the player.",
           "Their respective role varies on how they look, ranging from defensive to offensive to support from afar.",
           "  -The goblin flees after being hit, a very strong offensive enemy.",
           "  -The slime will act as the tank for the goblin, taking hits and distracting the player.",
           "  -The skeleton will rush at the player and attack and flee so the player has to move.",
           "  -The book will attack from range supporting the previous enemies.",
           "I had a blast making these ai's and have enjoyed learning from my fellow students on how to improve them further." 
        ],

        "languages": ["C#", "Unity"],
        "tags": ["3D", "Game", "Team", "World Generation"],
        "features": [
            "Procedurally generated dungeons",
            "Different enemy types with unique behaviors",
            "Fuzzy logic for enemy AI"
        ],
        "images": ["../Images/Wizcape/Wizcape_Dungeon_Generation.png", 
        "../Images/Wizcape/Wizcape_Thumbnail.png", 
        "../Images/Wizcape/Wizcape_Fighting.png", 
        "../Images/Wizcape/Wizcape_Trapped_Room.png"
      ],
      "code": [
],
        "codeCaption": "Nothing for now"
    },
    {
        "thumbnail": "",
        "id": "terratopia",
        "title": "Terratopia",
        "languages":["C#", "Unity", "Netcode"],
        "tags": ["Procedural Generation","World Generation", "Team", "Multiplayer", "3D", "Game"]

    }
]